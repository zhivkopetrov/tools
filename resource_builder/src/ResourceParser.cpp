// Corresponding header
#include "resource_builder/ResourceParser.h"

// System headers
#include <cctype>
#include <cerrno>
#include <cstring>
#include <functional>  //for std::hash

// Other libraries headers
#include "resource_utils/defines/ResourceDefines.h"
#include "resource_utils/common/ResourceFileHeader.h"
#include "utils/data_type/StringUtils.h"
#include "utils/file_system/FileSystemUtils.h"
#include "utils/ErrorCode.h"
#include "utils/Log.h"

// Own components headers

namespace {
static std::hash<std::string> hashFunction;

constexpr auto EXTERNAL_PATH_PREFIX = "external - ";
constexpr auto EXTERNAL_PATH_PREFIX_SIZE = 11;
constexpr auto MB_PRECISION_AFTER_DECIMAL = 3;
}

ResourceParser::ResourceParser()
    : _projectAbsFilePath("Not set") {
  resetInternals();
}

ErrorCode ResourceParser::init() {
  _projectAbsFilePath = FileSystemUtils::getRootDirectory();

  // Reserve enough memory for the whole parse process, no no unneeded
  // internal vector grow is invoked
  _fileData.reserve(200);

  return ErrorCode::SUCCESS;
}

ErrorCode ResourceParser::parseResourceTree(const std::string &projectName) {
  auto err = ErrorCode::SUCCESS;
  _startDir = _projectAbsFilePath;
  _startDir.append(projectName);
  _fileParser.setAbsoluteProjectPath(_startDir);
  _projectFolder = projectName;

  LOG("======================================");
  LOG("Starting recursive search on %s", _startDir.c_str());

  if (!FileSystemUtils::isDirectoryPresent(_startDir)) {
    LOGERR("Directory not present: [%s]", _startDir.c_str());
    return ErrorCode::FAILURE; //break early
  }

  err = ErrorCode::SUCCESS;
  if (ErrorCode::SUCCESS != setupResourceTree()) {
    LOGERR("Error, setupResourceTree() failed");
    err = ErrorCode::FAILURE;
  }

  if (ErrorCode::SUCCESS == err) {
    if (ErrorCode::SUCCESS != processAllFiles()) {
      LOGERR("processAllFiles() failed");
      err = ErrorCode::FAILURE;
    }
  }

  if (ErrorCode::SUCCESS == err) {
    _fileBuilder.finishCombinedDestFiles(_staticWidgetsCounter,
        _dynamicWidgetsCounter, _fontsCounter, _musicsCounter, _chunksCounter,
        _staticResFileTotalSize, _fontFileTotalSize, _soundFileTotalSize);
  }

  finishParseResourceTreeLogReport(err);

  // reset internal variables on both success and failure
  resetInternals();

  return err;
}

ErrorCode ResourceParser::setupResourceTree() {
  // files above are located in the build directory
  std::string projectAbsBuildFilePath = _projectAbsFilePath;
  projectAbsBuildFilePath.append(_projectFolder).append("/").append(
      ResourceFileHeader::getResourcesFolderName()).append("/").append(
      ResourceFileHeader::getAutoGeneratedFolderName());

  std::string resourcesFolder = projectAbsBuildFilePath;
  if (!FileSystemUtils::isDirectoryPresent(resourcesFolder)) {
    if (ErrorCode::SUCCESS !=
        FileSystemUtils::createDirectoryRecursive(resourcesFolder)) {
      LOGERR("createDirectoryRecursive() failed for '%s'",
          resourcesFolder.c_str());
      return ErrorCode::FAILURE;
    }
  }

  resourcesFolder.append("/");
  const std::string resFile = resourcesFolder
      + ResourceFileHeader::getResourceBinName();
  const std::string fontFile = resourcesFolder
      + ResourceFileHeader::getFontBinName();
  const std::string soundFile = resourcesFolder
      + ResourceFileHeader::getSoundBinName();

  if (ErrorCode::SUCCESS != _fileBuilder.openCombinedStreams(resFile, fontFile,
          soundFile)) {
    LOGERR("Error in _fileBuilder.openCombinedStreams()");
    return ErrorCode::FAILURE;
  }

  return ErrorCode::SUCCESS;
}

ErrorCode ResourceParser::processAllFiles() {
  const std::vector<std::string> blackListFolders { "build", "install" };
  std::vector<std::string> files;
  if (ErrorCode::SUCCESS !=
      FileSystemUtils::getAllFilesInDirectoryRecursively(_startDir,
          blackListFolders, files)) {
    LOGERR("getAllFilesInDirectoryRecursively() failed");
    return ErrorCode::FAILURE;
  }

  for (const auto &fileName : files) {
    // Skip file if it's not resource file
    if (!isResourceFile(fileName)) {
      continue;
    }
    _currAbsFilePath = fileName;

    if (ErrorCode::SUCCESS != buildResourceFile()) {
      LOGERR("Error in buildResourceFile() for %s.", _currAbsFilePath.c_str());
      LOGR("Cancelling parsing for next files");
      return ErrorCode::FAILURE;
    }
  }

  return ErrorCode::SUCCESS;
}

bool ResourceParser::isResourceFile(const std::string &fileName) const {
  bool result = false;

  // check wheter file has .rsrc extension
  const size_t pos = fileName.rfind(".rsrc");

  // file is found
  if (std::string::npos != pos) {
    result = true;
  }

  return result;
}

ErrorCode ResourceParser::openSourceStream(const std::string &sourceFileName) {
  // open fileStream for read
  _sourceStream.open(sourceFileName.c_str(),
      std::ifstream::in | std::ifstream::binary);

  if (!_sourceStream) {
    LOGERR("Error, could not open ifstream for fileName: %s, reason: %s",
        sourceFileName.c_str(), strerror(errno));
    return ErrorCode::FAILURE;
  }

  return ErrorCode::SUCCESS;
}

void ResourceParser::closeSourceStream() {
  // close the stream
  _sourceStream.close();

  // reset stream flags since we will be reusing it for other files
  _sourceStream.clear();
}

ErrorCode ResourceParser::buildResourceFile() {
  LOG_ON_SAME_LINE("Parsing %s ... ", _currAbsFilePath.c_str());

  auto err = buildResFileInternalData();

  if (ErrorCode::SUCCESS != err) {
    LOGERR("Error in buildResourceFile(), Resource file from %s could not be "
           "created", _currAbsFilePath.c_str());
  }

  if (ErrorCode::SUCCESS == err) {
    err = openSourceStream(_currAbsFilePath);

    if (ErrorCode::SUCCESS != err) {
      LOGERR("Error in openSourceStream(), Resource file from %s could not be "
             "created", _currAbsFilePath.c_str());
    }
  }

  if (ErrorCode::SUCCESS == err) {
    err = parseFileData();

    if (ErrorCode::SUCCESS != err) {
      LOGERR("Error in parseFileData() for %s", _currAbsFilePath.c_str());
    }
  }

  if (ErrorCode::SUCCESS == err) {
    err = _fileBuilder.openDestStreams();

    if (ErrorCode::SUCCESS != err) {
      LOGERR("Error in openDestStream() for %s", _currDestFile.c_str());
    }
  }

  if (ErrorCode::SUCCESS == err) {
    // whole .rsrc file is parsed -> write its data
    _fileBuilder.writeData(_fileData);

    LOGG("[Done]");
  } else {
    LOG_ON_SAME_LINE("Parsing of %s ... ", _currAbsFilePath.c_str());
    LOGR("[Failed]");
  }

  // close streams on both success or failure
  closeSourceStream();
  _fileBuilder.closeDestStream();
  _fileParser.resetRelativeFolderPath();

  return err;
}

ErrorCode ResourceParser::buildResFileInternalData() {
  uint64_t relativePrjPathStartIdx = 0;
  uint64_t relativePrjPathEndIdx = 0;

  relativePrjPathStartIdx = _currAbsFilePath.find(_projectFolder);
  if (relativePrjPathStartIdx == std::string::npos) {
    LOGERR("Internal error. Resource file from %s could not be created",
        _currAbsFilePath.c_str());
    return ErrorCode::FAILURE;
  }
  relativePrjPathStartIdx += _projectFolder.size() + 1;

  // locate dot index so we can substring the instance name
  const uint64_t dotPos = _currAbsFilePath.find(".");
  if (std::string::npos == dotPos) {
    LOGERR("Internal error. Resource file from %s could not be created",
        _currAbsFilePath.c_str());
    return ErrorCode::FAILURE;
  }

  const std::string absFileName = _currAbsFilePath.substr(0, dotPos);
  const std::string fileNameNoExtension =
      FileSystemUtils::getFileNameFromAbsolutePath(absFileName);
  relativePrjPathEndIdx = _currAbsFilePath.find(fileNameNoExtension);
  if (std::string::npos == relativePrjPathStartIdx) {
    LOGERR("Internal error. Resource file from %s could not be created",
        _currAbsFilePath.c_str());
    return ErrorCode::FAILURE;
  }

  // locate dot index so we can substring the instance name
  const uint64_t slashPos = _currAbsFilePath.rfind("/");
  if (std::string::npos == slashPos) {
    LOGERR("Internal error. Resource folder from %s could not be created",
        _currAbsFilePath.c_str());
    return ErrorCode::FAILURE;
  }

  const std::string absResourceFolderPath = _currAbsFilePath.substr(0,
      slashPos + 1);

  // get project path
  const std::string relativeProjectPath = _currAbsFilePath.substr(
      relativePrjPathStartIdx,  // start index
      relativePrjPathEndIdx - relativePrjPathStartIdx); // size

  // remember relative folder path before appending *project*_resources_h_
  _fileParser.setRelativeFolderPath(relativeProjectPath);

  _currHeaderGuard = _projectFolder;
  _currHeaderGuard.append("_RESOURCES_H_");

  for (auto &letter : _currHeaderGuard) {
    if (isalpha(letter)) {
      letter = static_cast<char>(std::toupper(letter));
    } else if (letter == '/') {
      letter = '_';
    }
  }

  _currDestFile = absResourceFolderPath;
  _currDestFile.append(ResourceFileHeader::getAutoGeneratedFolderName()).append(
      "/").append(fileNameNoExtension).append("Resources");

  _currNamespace = fileNameNoExtension;
  _currNamespace.append("Resources");

  _fileBuilder.setNamespace(_currNamespace);
  _fileBuilder.setDestFileName(_currDestFile);
  _fileBuilder.setHeaderGuards(_currHeaderGuard);

  return ErrorCode::SUCCESS;
}

ErrorCode ResourceParser::parseFileData() {
  _syntaxChecker.reset();

  std::string lineData = "";
  std::string rowData = "";
  int32_t eventCode = 0;
  int32_t parsedRowNumber = 0;

  CombinedData combinedData;

  // clear resources from previous parsed file
  _fileData.clear();

  while (std::getline(_sourceStream, lineData)) {
    ++parsedRowNumber;

    if (lineData.size() == 0) { // it is empty line -> skip it
      continue;
    } else if (lineData[0] == '#') { // it is comment line -> skip it
      continue;
    } else if (_syntaxChecker.hasValidTag(lineData)) {
      if (ErrorCode::SUCCESS != _syntaxChecker.extractRowData(lineData, rowData,
              eventCode)) {
        LOGERR("Error in extractRowData()");
        return ErrorCode::FAILURE;
      }

      if (ErrorCode::SUCCESS !=
          setSingleRowData(rowData, eventCode, combinedData)) {
        LOGERR("Error in setSingleRowData()");
        return ErrorCode::FAILURE;
      }
    } else {
      LOGERR("Internal error occurred on line: %d. Canceling parsing for %s",
             parsedRowNumber, _currAbsFilePath.c_str());
      return ErrorCode::FAILURE;
    }

    _syntaxChecker.updateOrder();

    if (_syntaxChecker.isChunkReady()) {
      // accumulate only TextureLoadType::ON_INIT widgets!
      if (_fileParser.isGraphicalFile() &&
          (ResourceDefines::TextureLoadType::ON_INIT
          == combinedData.textureLoadType)) {
        ++_staticWidgetsCounter;
        _staticResFileTotalSize += combinedData.header.fileSize;
      } else {
        ++_dynamicWidgetsCounter;
        _dynamicResFileTotalSize += combinedData.header.fileSize;
      }

      _fileData.emplace_back(combinedData);
      combinedData.reset();
      _fileParser.closeFileAndReset();
    }
  }

  if (_fileData.empty()) {
    LOGERR("Configuration not complete for %s", _currAbsFilePath.c_str());
    return ErrorCode::FAILURE;
  }

  return ErrorCode::SUCCESS;
}

ErrorCode ResourceParser::setSingleRowData(const std::string &rowData,
                                           const int32_t eventCode,
                                           CombinedData &outData) {
  switch (eventCode) {
  case ResourceDefines::Field::TAG:
    // get rid of the "[ ]" brackets
    outData.tagName = rowData.substr(1, rowData.size() - 2);
    break;

  case ResourceDefines::Field::TYPE:
    outData.type = rowData;
    _syntaxChecker.setFieldTypeFromString(rowData);
    break;

  case ResourceDefines::Field::PATH:
    if (ErrorCode::SUCCESS != fillPath(rowData, outData)) {
      LOGERR("Error in fillPath()");
      return ErrorCode::FAILURE;
    }
    break;

  case ResourceDefines::Field::DESCRIPTION:
    if (ErrorCode::SUCCESS != fillDescription(rowData, outData)) {
      LOGERR("Error in fillDescription()");
      return ErrorCode::FAILURE;
    }
    break;

  case ResourceDefines::Field::POSITION:
    if (ErrorCode::SUCCESS != setImagePosition(rowData, outData)) {
      LOGERR("Error in setImagePosition()");
      return ErrorCode::FAILURE;
    }
    break;

  case ResourceDefines::Field::LOAD:
    if (ErrorCode::SUCCESS != setTextureLoadType(rowData, outData)) {
      LOGERR("Error in setImagePosition()");
      return ErrorCode::FAILURE;
    }
    break;

  default:
    LOGERR("Error, invalid enum value %d", eventCode);
    return ErrorCode::FAILURE;
    break;
  }

  return ErrorCode::SUCCESS;
}

ErrorCode ResourceParser::fillPath(const std::string &relativeFilePath,
                                   CombinedData &outData) {
  if (std::string::npos == relativeFilePath.find(EXTERNAL_PATH_PREFIX)) {
    // use local folder hierarchy
    // Example: p/gui/archer.png
    _fileParser.setRelativeFilePath(relativeFilePath);
  } else {
    // use non-local file placement (file outside the local folder)
    // Example: gui/p/menu/add_button.png
    _fileParser.setCompleteFilePathFromProject(
        relativeFilePath.substr(EXTERNAL_PATH_PREFIX_SIZE,
            relativeFilePath.size() - EXTERNAL_PATH_PREFIX_SIZE));
  }

  if (ErrorCode::SUCCESS != _fileParser.openFile()) {
    LOGERR("Error in _fileParser.openFile()");
    return ErrorCode::FAILURE;
  }

  outData.header.fileSize = _fileParser.getFileSizeInKiloBytes();

  if (_fileParser.isSupportedExtension()) {
    //TODO Zhivko Petrov: change the next line with .getAbsoluteFilePath() to
    //                    get the full path. Relative path may lead to string
    //                    collisions and lose the possibility for
    //                    nested .rsrc files within a single project
    outData.header.path = _fileParser.getRelativeFilePath();

    //file is a duplicate, this indicate error (probably copy/paste error)
    if (_uniqueFiles.find(outData.header.path) != _uniqueFiles.end()) {
      LOGERR("Error, found duplicate file: %s", outData.header.path.c_str());
      LOGC(
          "Developer hint: correct your mistake in %s and re-run " "the res_builder tool",
          _currAbsFilePath.c_str());
      return ErrorCode::FAILURE;
    }
    _uniqueFiles.insert(outData.header.path);

    // calculate hash value from resource string location
    outData.header.hashValue = hashFunction(outData.header.path);

    if (_fileParser.isGraphicalFile()) {
      _fileParser.getImageDimension(outData.imageRect.w, outData.imageRect.h);
    }
  }

  return ErrorCode::SUCCESS;
}

ErrorCode ResourceParser::fillDescription(const std::string &rowData,
                                          CombinedData &outData) {
  switch (_syntaxChecker.getFieldType()) {
  case ResourceDefines::FieldType::IMAGE:
    outData.spriteData.emplace_back(0, // x
        0,                             // y
        outData.imageRect.w,           // w
        outData.imageRect.h);          // h
    break;

  case ResourceDefines::FieldType::SPRITE: {
    // reserve 4 slots for description parameters
    std::vector<int32_t> spriteDescription;
    constexpr uint32_t SPRITE_DATA_SIZE = 4;

    if (ErrorCode::SUCCESS != StringUtils::extractIntsFromString(rowData, " ,",
            &spriteDescription, SPRITE_DATA_SIZE)) {
      LOGERR("Error in extractIntsFromString() for data: [%s], "
             "delimiters: [ ,], maxNumbers: %d",
             rowData.c_str(), SPRITE_DATA_SIZE);
      return ErrorCode::FAILURE;
    }

    _fileParser.setSpriteDescription(spriteDescription);
    ResourceDefines::SpriteLayout spriteLayout =
        ResourceDefines::SpriteLayout::UNKNOWN;

    if (!_fileParser.isValidSpriteDescription(spriteLayout)) {
      LOGERR("Error wrong description for .rsrc file: %s, " "with tag: %s",
          _currAbsFilePath.c_str(), outData.tagName.c_str());
      return ErrorCode::FAILURE;
    }

    if (ErrorCode::SUCCESS != _fileParser.fillSpriteData(spriteLayout,
            outData.spriteData)) {
      LOGERR("Error in _fileParser.fillSpriteData()");
      return ErrorCode::FAILURE;
    }
  }
    break;

  case ResourceDefines::FieldType::SPRITE_MANUAL: {
    // reserve 4 slots for description parameters
    std::vector<int32_t> spriteDescription;
    constexpr uint32_t SPRITE_DATA_SIZE = 4;

    if (ErrorCode::SUCCESS != StringUtils::extractIntsFromString(rowData, " ,",
            &spriteDescription, SPRITE_DATA_SIZE)) {
      LOGERR("Error in extractIntsFromString() " "for data: [%s], "
             "delimiters: [ ,], maxNumbers: %d",
              rowData.c_str(), SPRITE_DATA_SIZE);
      return ErrorCode::FAILURE;
    }

    _fileParser.setSpriteDescription(spriteDescription);

    if (_fileParser.isValidSpriteManualDescription()) {
      outData.spriteData.emplace_back(spriteDescription[0],   // x
          spriteDescription[1],   // y
          spriteDescription[2],   // w
          spriteDescription[3]);  // h
    } else {
      LOGERR("Error wrong description for .rsrc file: %s, with tag: %s",
          _currAbsFilePath.c_str(), outData.tagName.c_str());
      return ErrorCode::FAILURE;
    }
  }
    break;

  case ResourceDefines::FieldType::FONT:
    outData.fontSize = StringUtils::safeStoi(rowData);
    ++_fontsCounter;
    _fontFileTotalSize += outData.header.fileSize;
    break;

  case ResourceDefines::FieldType::SOUND: {
    std::vector<std::string> tokens;
    constexpr uint32_t MAX_TOKEN_SIZE = 2;
    StringUtils::tokenize(rowData, ", ", &tokens, MAX_TOKEN_SIZE);

    if (MAX_TOKEN_SIZE != tokens.size()) {
      LOGERR("Error wrong description for .rsrc file: %s, with tag: %s",
          _currAbsFilePath.c_str(), outData.tagName.c_str());
      return ErrorCode::FAILURE;
    }

    const auto &soundWidgetType = tokens[0];
    if ("chunk" == soundWidgetType) {
      ++_chunksCounter;
      outData.soundType = soundWidgetType;
    } else if ("music" == soundWidgetType) {
      ++_musicsCounter;
      outData.soundType = soundWidgetType;
    } else {
      LOGERR("Error wrong description for .rsrc file: %s, with "
            "tag: %s. First argument must be 'music' or 'chunk'",
            _currAbsFilePath.c_str(), outData.tagName.c_str());
      return ErrorCode::FAILURE;
    }

    const auto &soundLevelType = tokens[1];
    if ("low" == soundLevelType || "medium" == soundLevelType
        || "high" == soundLevelType || "very_high" == soundLevelType) {
      outData.soundLevel = soundLevelType;
      _soundFileTotalSize += outData.header.fileSize;
    } else {
      LOGERR("Error wrong description for .rsrc file: %s, with "
             "tag: %s. Second argument 'sound level' must be "
             "'low', 'medium', 'high' or 'very_high'",
             _currAbsFilePath.c_str(), outData.tagName.c_str());
      return ErrorCode::FAILURE;
    }
  }
    break;

  default:
    LOGERR("Internal error, unknown CombinedData.type : %s",
        outData.type.c_str());
    return ErrorCode::FAILURE;
  }

  return ErrorCode::SUCCESS;
}

ErrorCode ResourceParser::setImagePosition(const std::string &rowData,
                                           CombinedData &outData) {
  std::vector<int32_t> data;
  constexpr uint32_t DATA_SIZE = 2;

  if (ErrorCode::SUCCESS ==
      StringUtils::extractIntsFromString(rowData, " ,", &data, DATA_SIZE)) {
    outData.imageRect.x = data[0];
    outData.imageRect.y = data[1];
  } else {
    LOGERR("Error in extractIntsFromString() for data: %s, maxNumbers: %d",
        rowData.c_str(), DATA_SIZE);
    return ErrorCode::FAILURE;
  }

  return ErrorCode::SUCCESS;
}

ErrorCode ResourceParser::setTextureLoadType(const std::string &rowData,
                                             CombinedData &outData) {
  if ("on_init" == rowData) {
    outData.textureLoadType = ResourceDefines::TextureLoadType::ON_INIT;
  } else if ("on_demand" == rowData) {
    outData.textureLoadType = ResourceDefines::TextureLoadType::ON_DEMAND;
  } else {
    LOGERR("Error wrong description for .rsrc file: %s, with tag: "
           "%s. Second argument must be 'on_init' or 'on_demand'",
           _currAbsFilePath.c_str(), outData.tagName.c_str());
    return ErrorCode::FAILURE;
  }

  return ErrorCode::SUCCESS;
}

void ResourceParser::resetInternals() {
  _startDir = "Not set";
  _currAbsFilePath = "Not set";
  _currDestFile = "Not set";
  _currHeaderGuard = "Not set";
  _currNamespace = "Not set";
  _staticWidgetsCounter = 0;
  _dynamicWidgetsCounter = 0;
  _fontsCounter = 0;
  _musicsCounter = 0;
  _chunksCounter = 0;
  _staticResFileTotalSize = 0;
  _dynamicResFileTotalSize = 0;
  _fontFileTotalSize = 0;
  _soundFileTotalSize = 0;

  _syntaxChecker.reset();
  _fileData.clear();
}

void ResourceParser::finishParseResourceTreeLogReport(
    const ErrorCode errorCode) {
  if (ErrorCode::SUCCESS == errorCode) {
    constexpr int32_t CONTAINERS_SIZE = 4;
    const int32_t ITEMS_SIZE[CONTAINERS_SIZE] { _staticResFileTotalSize,
        _dynamicResFileTotalSize, _fontFileTotalSize, _soundFileTotalSize };

    std::string itemsSizeStr[CONTAINERS_SIZE];

    for (int32_t i = 0; i < CONTAINERS_SIZE; ++i) {
      itemsSizeStr[i] = std::to_string(
          static_cast<double>(ITEMS_SIZE[i]) / 1024);
      const size_t DOT_POS = itemsSizeStr[i].find('.');

      itemsSizeStr[i] = (itemsSizeStr[i].substr(0,
          DOT_POS + 1 + MB_PRECISION_AFTER_DECIMAL));
      itemsSizeStr[i].append(" MB");
    }

    LOG_ON_SAME_LINE("\nRecursive search on %s ... ", _startDir.c_str());
    LOGG("[Done]");

    LOG_ON_SAME_LINE("%s generation ... (%lu static files with size: %s "
        "and %lu dynamic files with size: %s) ",
        ResourceFileHeader::getResourceBinName().c_str(), _staticWidgetsCounter,
        itemsSizeStr[0].c_str(), _dynamicWidgetsCounter,
        itemsSizeStr[1].c_str());
    LOGG("[Done]");
    LOG_ON_SAME_LINE("%s generation ... (%lu static files with size: %s) ",
        ResourceFileHeader::getFontBinName().c_str(), _fontsCounter,
        itemsSizeStr[2].c_str());
    LOGG("[Done]");
    LOG_ON_SAME_LINE("%s generation ... (%lu static files with size: %s) ",
        ResourceFileHeader::getSoundBinName().c_str(),
        (_musicsCounter + _chunksCounter), itemsSizeStr[3].c_str());
    LOGG("[Done]");
  } else {
    LOG_ON_SAME_LINE("\nRecursive search on %s ... ", _startDir.c_str());
    LOGR("[Failed]");
    LOG_ON_SAME_LINE("%s generation ... ",
        ResourceFileHeader::getResourceBinName().c_str());
    LOGR("[Failed]");
    LOG_ON_SAME_LINE("%s generation ... ",
        ResourceFileHeader::getFontBinName().c_str());
    LOGR("[Failed]");
    LOG_ON_SAME_LINE("%s generation ... ",
        ResourceFileHeader::getSoundBinName().c_str());
    LOGR("[Failed]");
  }
  LOG("=======================================");
}
